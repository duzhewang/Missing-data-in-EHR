dev.off()
jpeg(file=paste(path, 'beta1.png', sep="/"))
traceplot(x=as.mcmc(beta_keep[-(1:burnin),1]), ylab="beta_1")
dev.off()
jpeg(file=paste(path, 'beta2.png', sep="/"))
traceplot(x=as.mcmc(beta_keep[-(1:burnin),2]), ylab="beta_2")
dev.off()
jpeg(file=paste(path, 'M2.png', sep="/"))
traceplot(x=as.mcmc(M_keep[-(1:burnin),2]), ylab="M_2")
dev.off()
jpeg(file=paste(path, 'M3.png', sep="/"))
traceplot(x=as.mcmc(M_keep[-(1:burnin),3]), ylab="M_3")
dev.off()
jpeg(file=paste(path, 'M4.png', sep="/"))
traceplot(x=as.mcmc(M_keep[-(1:burnin),4]), ylab="M_4")
dev.off()
jpeg(file=paste(path, 'sgmr2.png', sep="/"))
traceplot(x=as.mcmc(sgmr2_keep[-(1:burnin)]), ylab="sgmr2")
dev.off()
jpeg(file=paste(path, 'sgm2.png', sep="/"))
traceplot(x=as.mcmc(sgm2_keep[-(1:burnin)]), ylab="sgm2")
dev.off()
jpeg(file=paste(path, 'E.png', sep="/"))
traceplot(x=as.mcmc(E_keep[-(1:burnin)]), ylab="E")
dev.off()
#-----------------------------------------------------
# this script is used to run mcmc and do diagnostics
# Last updated date: 7/18/2017
#----------------------------------------------------
setwd("/Users/peterwang/Desktop/Research/missingdata/Project/code/CompleteDataSim/method1")
##run n_iter iterations
system.time(source("cpl_mcmc_update.R"))
burnin=5
##posterior mean
(posterior.mean.eta=apply(eta_keep[-(1:burnin),],2, mean))
(posterior.mean.M=apply(M_keep[-(1:burnin),],2, mean))
(posterior.mean.v=apply(v_keep[-(1:burnin),],2, mean))
(posterior.mean.beta=apply(beta_keep[-(1:burnin),],2, mean))
(posterior.mean.sgmr2=mean(sgmr2_keep[-(1:burnin)]))
(posterior.mean.sgm2=mean(sgm2_keep[-(1:burnin)]))
(posterior.mean.E=mean(E_keep[-(1:burnin)]))
##traceplots after burn-in
path="/Users/peterwang/Desktop/Research/missingdata/Project/code/CompleteDataSim/method1/results"
jpeg(file=paste(path, 'eta2.png', sep="/"))
traceplot(x=as.mcmc(eta_keep[-(1:burnin),2]), ylab="eta_2")
dev.off()
jpeg(file=paste(path, 'eta3.png', sep="/"))
traceplot(x=as.mcmc(eta_keep[-(1:burnin),3]), ylab="eta_3")
dev.off()
jpeg(file=paste(path, 'eta4.png', sep="/"))
traceplot(x=as.mcmc(eta_keep[-(1:burnin),4]), ylab="eta_4")
dev.off()
jpeg(file=paste(path, 'v1.png', sep="/"))
traceplot(x=as.mcmc(v_keep[-(1:burnin),1]), ylab="v_1")
dev.off()
jpeg(file=paste(path, 'v2.png', sep="/"))
traceplot(x=as.mcmc(v_keep[-(1:burnin),2]), ylab="v_2")
dev.off()
jpeg(file=paste(path, 'beta1.png', sep="/"))
traceplot(x=as.mcmc(beta_keep[-(1:burnin),1]), ylab="beta_1")
dev.off()
jpeg(file=paste(path, 'beta2.png', sep="/"))
traceplot(x=as.mcmc(beta_keep[-(1:burnin),2]), ylab="beta_2")
dev.off()
jpeg(file=paste(path, 'M2.png', sep="/"))
traceplot(x=as.mcmc(M_keep[-(1:burnin),2]), ylab="M_2")
dev.off()
jpeg(file=paste(path, 'M3.png', sep="/"))
traceplot(x=as.mcmc(M_keep[-(1:burnin),3]), ylab="M_3")
dev.off()
jpeg(file=paste(path, 'M4.png', sep="/"))
traceplot(x=as.mcmc(M_keep[-(1:burnin),4]), ylab="M_4")
dev.off()
jpeg(file=paste(path, 'sgmr2.png', sep="/"))
traceplot(x=as.mcmc(sgmr2_keep[-(1:burnin)]), ylab="sgmr2")
dev.off()
jpeg(file=paste(path, 'sgm2.png', sep="/"))
traceplot(x=as.mcmc(sgm2_keep[-(1:burnin)]), ylab="sgm2")
dev.off()
jpeg(file=paste(path, 'E.png', sep="/"))
traceplot(x=as.mcmc(E_keep[-(1:burnin)]), ylab="E")
dev.off()
ss=matrix(c(1,2,2,1),2,2)
ss
chol(ss)
ss=matrix(c(2,1,1,2),2,2)
ss
chol(ss)
matrix(1, 2,2)
#-----------------------------------------------------
# this script is used to update mcmc using method 2
# Last updated date: 7/18/2017
#-----------------------------------------------------
setwd("/Users/peterwang/Desktop/Research/missingdata/Project/code/CompleteDataSim/method2")
source("cpl_data_generation_m2.R")
#------------
# PRIORS
#------------
beta_pri=10^{4}
M_pri=10^{4}
sgm2_pri=0.001
sgmr2_pri=0.001
v_pri=10^{4}
E_pri=0.001
eta_pri=10^{4}
#------------------------
# SET INITIAL VALUES
#------------------------
inits=list(eta=c(0, 0.2, 1.3, 0.7),
beta=c(-0.5, 0.8),
M=c(0, 0.5, 1.4, -0.4),
v=c(0.3, -1),
sgmr2=1.5^2,
sgm2=1.5^2,
E=1.5^2,
b=rnorm(n, mean=0, sd=1.5),             ##initial value of random effect b_{i}
e=rnorm(n, mean=0, sd=1.5)              ##initial value of random effect e_{i}
)
#-----------------------
#   SET-UP OF ITERATION
#-----------------------
#number of iterations
n_iter=10000
##variable names in the iteration
eta=inits$eta
v=inits$v
beta=inits$beta
M=inits$M
sgmr2=inits$sgmr2
sgm2=inits$sgm2
E=inits$E
c=vector(length=n)
b=inits$b
e=inits$e
X=X_sim
##recording structure, each row is one iteration
eta_keep=matrix(0, nrow=n_iter, ncol=K)
v_keep=matrix(0, nrow=n_iter, ncol=2)
beta_keep=matrix(0, nrow=n_iter, ncol=2)
M_keep=matrix(0, nrow=n_iter, ncol=K)
sgmr2_keep=rep(0, n_iter)
sgm2_keep=rep(0, n_iter)
E_keep=rep(0, n_iter)
c_keep=matrix(0, nrow=n_iter, ncol=n)
b_keep=matrix(0, nrow=n_iter, ncol=n)
e_keep=matrix(0, nrow=n_iter, ncol=n)
Pi_c=matrix(0, n, K)        ## for updating c
f_c=matrix(0,n, K)          ## for updating c
LD=matrix(0, sum(T), 2)     ## for updating beta
La=vector(length=sum(T))    ## for updating beta
PG_eta=matrix(0, n, K-1)    ## for w_{il} in updating eta_{l}
k_eta=matrix(0, n, K-1)     ## for k_{l} in updating eta_{l}
omega_v=rep(0, sum(T))      ##for updating v
##sample c_{i} for all i
Pi_c=exp(V_sim%o%eta)
for(i in 1:n){
Pi_c[i, ]=prop.table(Pi_c[i,])
}
for(i in 1:n){
for (l in 1:K){
pos=(sum(T[1:i])-T[i]+1):sum(T[1:i])
f_c[i,l]=dmvnorm(X[pos], mean=D[pos,]%*%beta+D_star[pos]*M[l]+D_dstar[pos]*b[i],
sigma=sgm2*diag(T[i]) )
}
}
for(i in 1:n){
prob=(Pi_c*f_c)[i, ]
if (all(prob==0) ){
c[i]=rcat(n=1, p=rep(1/K, K))
} else {
c[i]=rcat(n=1, p=prob/sum(prob) )
}
}
##sample eta2, eta3 and eta4
for(l in 2:K){
for(i in 1:n){
tilting_eta=V_sim[i]*eta[l]-log(sum(exp(V_sim[i]*eta[-l])) )
PG_eta[i,l-1]=rpg(num=1, h=1, z=tilting_eta)  ## sample w_{il}
index_eta=ifelse(c[i]==l,1,0)
k_eta[i,l-1]=index_eta-1/2+PG_eta[i,l-1]*log(sum(exp(V_sim[i]*eta[-l])))
}
S_eta=(1/eta_pri+t(V_sim)%*%diag(PG_eta[,l-1])%*%V_sim)^{-1}
m_eta=S_eta*crossprod(V_sim, k_eta[ ,l-1])
eta[l]=rnorm(n=1,mean=m_eta, sd=sqrt(S_eta))
}
##sample M2, M3 and M4
Bigb=rep(b, T)
for(l in 2:K){
c_index=rep(0, n)
index=which(c==l)
c_index[index]=1
var_M=((1/M_pri)+(1/sgm2)*sum((D_star*rep(c_index,T))^2))^{-1}
mean_M=(1/sgm2)*var_M*sum((D_star*(X-D%*%beta-D_dstar*Bigb))*rep(c_index,T))
M[l]=rnorm(1, mean=mean_M, sd=sqrt(var_M))
}
##sample beta
for (i in 1:n){
posD=(sum(T[1:i])-T[i]+1):sum(T[1:i])
InvW=sgmr2*matrix(1,T[i],T[i])+sgm2*diag(T[i])
InvCholW=solve(t(chol(InvW)))
LD[posD,2]=InvCholW%*%D[posD, ]
La[posD]=InvCholW%*%(X[posD]-D_star[posD]*M[c[i]])
}
var_beta=solve((1/beta_pri)*diag(2)+ crossprod(LD))
mean_beta=var_beta%*%crossprod(LD, La)
beta=mvrnorm(n=1, mu=mean_beta, Sigma = var_beta)
for (i in 1:n){
posD=(sum(T[1:i])-T[i]+1):sum(T[1:i])
InvW=sgmr2*matrix(1,T[i],T[i])+sgm2*diag(T[i])
InvCholW=solve(t(chol(InvW)))
LD[posD,]=InvCholW%*%D[posD, ]
La[posD]=InvCholW%*%(X[posD]-D_star[posD]*M[c[i]])
}
var_beta=solve((1/beta_pri)*diag(2)+ crossprod(LD))
mean_beta=var_beta%*%crossprod(LD, La)
beta=mvrnorm(n=1, mu=mean_beta, Sigma = var_beta)
beta
#-----------------------------------------------------
# this script is used to update mcmc using method 2
# Last updated date: 7/18/2017
#-----------------------------------------------------
setwd("/Users/peterwang/Desktop/Research/missingdata/Project/code/CompleteDataSim/method2")
source("cpl_data_generation_m2.R")
#------------
# PRIORS
#------------
beta_pri=10^{4}
M_pri=10^{4}
sgm2_pri=0.001
sgmr2_pri=0.001
v_pri=10^{4}
E_pri=0.001
eta_pri=10^{4}
#------------------------
# SET INITIAL VALUES
#------------------------
inits=list(eta=c(0, 0.2, 1.3, 0.7),
beta=c(-0.5, 0.8),
M=c(0, 0.5, 1.4, -0.4),
v=c(0.3, -1),
sgmr2=1.5^2,
sgm2=1.5^2,
E=1.5^2,
b=rnorm(n, mean=0, sd=1.5),             ##initial value of random effect b_{i}
e=rnorm(n, mean=0, sd=1.5)              ##initial value of random effect e_{i}
)
#-----------------------
#   SET-UP OF ITERATION
#-----------------------
#number of iterations
n_iter=10000
##variable names in the iteration
eta=inits$eta
v=inits$v
beta=inits$beta
M=inits$M
sgmr2=inits$sgmr2
sgm2=inits$sgm2
E=inits$E
c=vector(length=n)
b=inits$b
e=inits$e
X=X_sim
##recording structure, each row is one iteration
eta_keep=matrix(0, nrow=n_iter, ncol=K)
v_keep=matrix(0, nrow=n_iter, ncol=2)
beta_keep=matrix(0, nrow=n_iter, ncol=2)
M_keep=matrix(0, nrow=n_iter, ncol=K)
sgmr2_keep=rep(0, n_iter)
sgm2_keep=rep(0, n_iter)
E_keep=rep(0, n_iter)
c_keep=matrix(0, nrow=n_iter, ncol=n)
b_keep=matrix(0, nrow=n_iter, ncol=n)
e_keep=matrix(0, nrow=n_iter, ncol=n)
Pi_c=matrix(0, n, K)        ## for updating c
f_c=matrix(0,n, K)          ## for updating c
LD=matrix(0, sum(T), 2)     ## for updating beta
La=vector(length=sum(T))    ## for updating beta
PG_eta=matrix(0, n, K-1)    ## for w_{il} in updating eta_{l}
k_eta=matrix(0, n, K-1)     ## for k_{l} in updating eta_{l}
omega_v=rep(0, sum(T))      ##for updating v
##sample c_{i} for all i
Pi_c=exp(V_sim%o%eta)
for(i in 1:n){
Pi_c[i, ]=prop.table(Pi_c[i,])
}
for(i in 1:n){
for (l in 1:K){
pos=(sum(T[1:i])-T[i]+1):sum(T[1:i])
f_c[i,l]=dmvnorm(X[pos], mean=D[pos,]%*%beta+D_star[pos]*M[l]+D_dstar[pos]*b[i],
sigma=sgm2*diag(T[i]) )
}
}
for(i in 1:n){
prob=(Pi_c*f_c)[i, ]
if (all(prob==0) ){
c[i]=rcat(n=1, p=rep(1/K, K))
} else {
c[i]=rcat(n=1, p=prob/sum(prob) )
}
}
##sample eta2, eta3 and eta4
for(l in 2:K){
for(i in 1:n){
tilting_eta=V_sim[i]*eta[l]-log(sum(exp(V_sim[i]*eta[-l])) )
PG_eta[i,l-1]=rpg(num=1, h=1, z=tilting_eta)  ## sample w_{il}
index_eta=ifelse(c[i]==l,1,0)
k_eta[i,l-1]=index_eta-1/2+PG_eta[i,l-1]*log(sum(exp(V_sim[i]*eta[-l])))
}
S_eta=(1/eta_pri+t(V_sim)%*%diag(PG_eta[,l-1])%*%V_sim)^{-1}
m_eta=S_eta*crossprod(V_sim, k_eta[ ,l-1])
eta[l]=rnorm(n=1,mean=m_eta, sd=sqrt(S_eta))
}
##sample M2, M3 and M4
Bigb=rep(b, T)
for(l in 2:K){
c_index=rep(0, n)
index=which(c==l)
c_index[index]=1
var_M=((1/M_pri)+(1/sgm2)*sum((D_star*rep(c_index,T))^2))^{-1}
mean_M=(1/sgm2)*var_M*sum((D_star*(X-D%*%beta-D_dstar*Bigb))*rep(c_index,T))
M[l]=rnorm(1, mean=mean_M, sd=sqrt(var_M))
}
##sample beta
for (i in 1:n){
posD=(sum(T[1:i])-T[i]+1):sum(T[1:i])
InvW=sgmr2*matrix(1,T[i],T[i])+sgm2*diag(T[i])
InvCholW=solve(t(chol(InvW)))
LD[posD,]=InvCholW%*%D[posD, ]
La[posD]=InvCholW%*%(X[posD]-D_star[posD]*M[c[i]])
}
var_beta=solve((1/beta_pri)*diag(2)+ crossprod(LD))
mean_beta=var_beta%*%crossprod(LD, La)
beta=mvrnorm(n=1, mu=mean_beta, Sigma = var_beta)
##sample b[i]
BigM=rep(M[c],T)
for (i in 1:n){
b_index=c(rep(0,i-1),1,rep(0, n-i))
var_b=((1/sgmr2)+(1/sgm2)*T[i])^{-1}
mean_b=(1/sgm2)*var_b*sum((X-D%*%beta-D_star*BigM)*rep(b_index,T))
b[i]=rnorm(1, mean=mean_b, sd=sqrt(var_b))
}
##sample sigma_{r}^{2}
sgmr2=rigamma(n=1, a=(n/2)+sgmr2_pri, b=(1/2)*sum(b^{2})+sgmr2_pri)
##sample sigma^{2}
Bigb=rep(b, T)
sum_sgm2=sum((X-D%*%beta-D_star*BigM-D_dstar*Bigb)^2)
shape_sgm2=(1/2)*sum(T)+sgm2_pri
scale_sgm2=(1/2)*sum_sgm2+sgm2_pri
sgm2=rigamma(n=1, a=shape_sgm2, b=scale_sgm2)
##sample v
tilting_v=BigVX%*%v+rep(e,T)
for (i in 1:sum(T)){
omega_v[i]=rpg(num=1, h=1, z=tilting_v[i])  ## sample w_{it}^{*}
}
k_v=Y_sim-omega_v*rep(e, T)-1/2
S_v=solve((1/v_pri)*diag(2)+crossprod(BigVX,diag(omega_v))%*%BigVX )
m_v=S_v%*%crossprod(BigVX,k_v)
v=mvrnorm(n=1, mu=m_v, Sigma = S_v)
##sample e_{i}
for(i in 1:n){
e_index=c(rep(0,i-1),1,rep(0, n-i))
S_e=((1/E)+sum(omega_v*rep(e_index, T)))^{-1}
m_e=S_e*sum((Y_sim-omega_v*(BigVX%*%v)-1/2)*rep(e_index, T))
e[i]=rnorm(n=1, mean=m_e, sd=sqrt(S_e))
}
##sample E
E=rigamma(n=1, a=n/2+E_pri, b=(1/2)*sum(e^{2})+E_pri)
# this script is used to run mcmc and do diagnostics
# Last updated date: 7/18/2017
#----------------------------------------------------
setwd("/Users/peterwang/Desktop/Research/missingdata/Project/code/CompleteDataSim/method2")
##run n_iter iterations
system.time(source("cpl_mcmc_update_m2.R"))
burnin=5
##posterior mean
(posterior.mean.eta=apply(eta_keep[-(1:burnin),],2, mean))
(posterior.mean.M=apply(M_keep[-(1:burnin),],2, mean))
(posterior.mean.v=apply(v_keep[-(1:burnin),],2, mean))
(posterior.mean.beta=apply(beta_keep[-(1:burnin),],2, mean))
(posterior.mean.sgmr2=mean(sgmr2_keep[-(1:burnin)]))
(posterior.mean.sgm2=mean(sgm2_keep[-(1:burnin)]))
(posterior.mean.E=mean(E_keep[-(1:burnin)]))
##traceplots after burn-in
path="/Users/peterwang/Desktop/Research/missingdata/Project/code/CompleteDataSim/method2/results"
jpeg(file=paste(path, 'eta2.png', sep="/"))
traceplot(x=as.mcmc(eta_keep[-(1:burnin),2]), ylab="eta_2")
dev.off()
jpeg(file=paste(path, 'eta3.png', sep="/"))
traceplot(x=as.mcmc(eta_keep[-(1:burnin),3]), ylab="eta_3")
dev.off()
jpeg(file=paste(path, 'eta4.png', sep="/"))
traceplot(x=as.mcmc(eta_keep[-(1:burnin),4]), ylab="eta_4")
dev.off()
jpeg(file=paste(path, 'v1.png', sep="/"))
traceplot(x=as.mcmc(v_keep[-(1:burnin),1]), ylab="v_1")
dev.off()
jpeg(file=paste(path, 'v2.png', sep="/"))
traceplot(x=as.mcmc(v_keep[-(1:burnin),2]), ylab="v_2")
dev.off()
jpeg(file=paste(path, 'beta1.png', sep="/"))
traceplot(x=as.mcmc(beta_keep[-(1:burnin),1]), ylab="beta_1")
dev.off()
jpeg(file=paste(path, 'beta2.png', sep="/"))
traceplot(x=as.mcmc(beta_keep[-(1:burnin),2]), ylab="beta_2")
dev.off()
jpeg(file=paste(path, 'M2.png', sep="/"))
traceplot(x=as.mcmc(M_keep[-(1:burnin),2]), ylab="M_2")
dev.off()
jpeg(file=paste(path, 'M3.png', sep="/"))
traceplot(x=as.mcmc(M_keep[-(1:burnin),3]), ylab="M_3")
dev.off()
jpeg(file=paste(path, 'M4.png', sep="/"))
traceplot(x=as.mcmc(M_keep[-(1:burnin),4]), ylab="M_4")
dev.off()
jpeg(file=paste(path, 'sgmr2.png', sep="/"))
traceplot(x=as.mcmc(sgmr2_keep[-(1:burnin)]), ylab="sgmr2")
dev.off()
jpeg(file=paste(path, 'sgm2.png', sep="/"))
traceplot(x=as.mcmc(sgm2_keep[-(1:burnin)]), ylab="sgm2")
dev.off()
jpeg(file=paste(path, 'E.png', sep="/"))
traceplot(x=as.mcmc(E_keep[-(1:burnin)]), ylab="E")
dev.off()
c(1,2,3)%o%c(1,1,1)
#--------------------------------------------------------------------------
# This script is used to generate the simulated data with missing values
# Last updated date: 7/20/2017
#--------------------------------------------------------------------------
rm(list=ls())
set.seed(0311)
library(MASS) ##use function mvrnorm
library(LaplacesDemon) ##use function rcat
library(MCMCpack) ##use function rinvgamma, default rate=1
library(mvtnorm)  ##use function dmvnorm, rmvt
library(pscl)  ##use function rigamma
#library(metRology)  ##use function rt.scaled
library(BayesLogit) ##use rpg
library(coda)
library(LearnBayes)
#library(doParallel)
#---------------------------------
#      Global set-up
#---------------------------------
n=100 ##number of subject
K=4 ##number of latent classes
##assign each subject the number of tracked quarters
T=sample(5:40, size=n, replace=TRUE)
#--------------------------------------
#   Complete simulated data generation
#--------------------------------------
##set up true values of parameters
eta_sim=c(0, 0.5, 1.5, 1)
beta_sim=c(-0.4, 0.5)
M_sim=c(0, -0.6, 0.6, 1.2)
v_sim=c(0.5, -0.3)
sgmr2_sim=1                ##true value of variance of b_{i}
sgm2_sim=1                 ##true value of variance of epsilon_{it}
E_sim=1                    ##true value of variance of e_{i}
##generate time-invariate covariate V_{i}
V_sim=rnorm(n=n, mean=0, sd=1)
##simulate latent class c[i] for each subject
Pi_sim=exp(V_sim%o%eta_sim)
c_sim=apply(Pi_sim, 1, function(x) rcat(n=1, p=x/sum(x)))
##generate random effect b_{i}
b_sim=rnorm(n,mean=0, sd=sqrt(sgmr2_sim))
##set D_{i}, D^{*}_{i} and D^{**}_{i}
D=matrix(0, sum(T), 2)
D[,1]=rep(1,sum(T))
D[,2]=rep(V_sim,T)
D_star=vector(length=sum(T))
for(i in 1:n){
D_star[(sum(T[1:i])-T[i]+1):sum(T[1:i])]=1:T[i]
}
D_dstar=rep(1, sum(T))
##simulate X_{it}
BigM=rep(M_sim[c_sim],T)
Bigb=rep(b_sim, T)
X_sim=D%*%beta_sim+D_star*BigM+D_dstar*Bigb+rnorm(n=sum(T), mean=0, sd=sqrt(sgm2_sim))
##generate random effect e_{i}
e_sim=rnorm(n, mean=0, sd=sqrt(E_sim))
##generate y_{it}
BigVX=matrix(0, sum(T), 2)
BigVX[, 1]=rep(V_sim,T)
BigVX[, 2]=X_sim
top=exp(BigVX%*%v_sim+rep(e_sim,T))
bot=1+top
Y_sim=rbinom(n=sum(T), size=1, p=top/bot)
#--------------------------------
# SET MISSING VALUES: 20% MCAR
#--------------------------------
mr=0.2 ##missing rate
R_sim=rbinom(sum(T), 1, 1-mr)  ##R=0 represents missing
XR=data.frame(X=X_sim, R=R_sim)
XR
R_sim
X_sim[R_sim==0]
XR
(XR$X)[R_sim==0]
sum(R_sim==0)
head(XR)
# set size of matrix
N <- 500
# create matrices
D <- diag(runif(N))
M <- array(runif(N * N), dim = c(N, N))
# compute product / compare time
system.time(Z1 <- D %*% M %*% D)
system.time(Z2 <- outer(diag(D), diag(D)) * M)
# check difference between matrices
max(abs(Z1 - Z2))
outer(c(1,2,3),c(4,5,6))
